
<link rel="import" href="../../components/iron-signals/iron-signals.html">
<link rel="import" href="../../components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../components/paper-button/paper-button.html">
<link rel="import" href="../../components/neon-animation/neon-animation.html">
<link rel="import" href="../../components/paper-checkbox/paper-checkbox.html">

<link rel="import" href="./ts-read-mode/ts-read-mode.html">
<link rel="import" href="./ts-chunk-mode/ts-chunk-mode.html">
<link rel="import" href="./ts-review-mode/ts-review-mode.html">
<link rel="import" href="./ts-translate-sidebar.html">
<link rel="import" href="./ts-nosource-mode.html">
<link rel="import" href="./ts-source/ts-source-modal.html">
<link rel="import" href="../ts-main/ts-loading.html">

<dom-module id="ts-translate">

    <style>

        :host {
            display: flex;
        }

        #pages {
            flex: auto;
            display: flex;
            position: relative;
        }

        .popup {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }

        #checklistpopup {
            width: 350px;
            height: 225px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #checklistpopup p {
            margin: 0;
        }

        #checklistpopup p#spaced {
            margin-bottom: 15px;
        }

        #checklistpopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #checklistpopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #editpopup {
            width: 350px;
            height: 175px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #editpopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #editpopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #sourcepopup {
            height: 500px;
            width: 500px;
            display: flex;
        }

        #sourcepopup * {
            margin: 0;
            padding: 0;
        }

        #nodatapopup {
            width: 300px;
            height: 175px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #nodatapopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #nodatapopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #delete {
            width: 450px;
            height: 175px;
        }

        #delete iron-icon {
            padding-right: 10px;
        }

        #delete p {
            font-size: 110%;
        }

        #deletebuttons {
            display: flex;
            justify-content: flex-end;
            padding: 0 50px;
            color: var(--secondary-text-color);
        }

        #deletebuttons paper-button:hover {
            color: var(--accent-color);
        }

        #note {
            width: 350px;
            height: 250px;
        }

        #notebuttons {
            display: flex;
            justify-content: flex-end;
            padding: 0 50px;
            color: var(--secondary-text-color);
        }

        #notebuttons paper-button:hover {
            color: var(--accent-color);
        }

        #printpopup {
            width: 450px;
            height: 280px;
            font-size: 110%;
        }

        #printbuttons {
            display: flex;
            justify-content: flex-end;
            align-items: center;
            padding: 0 10px;
            color: var(--secondary-text-color);
            border-top: 1px solid var(--border-color);
        }

        #printbuttons paper-button:hover {
            color: var(--accent-color);
        }

        paper-checkbox {
            --paper-checkbox-checked-color: var(--accent-color-dark);
            --paper-checkbox-unchecked-color: var(--accent-color-dark);
        }

        #loading {
            width: 320px;
            height: 220px;
        }

        #loading * {
            margin: 0;
            padding: 0;
        }

        .nodisplay {
            display: none;
        }

    </style>

    <template>

        <ts-translate-sidebar selected="{{selected}}" currentproject="[[currentproject]]" on-gohome="gohome" on-gopublish="gopublish" on-gobackup="gobackup" on-goprint="goprint" on-gosettings="gosettings"></ts-translate-sidebar>

        <div id="pages">
            <ts-read-mode id="readmode" chapters="[[currentproject.chapters]]" modestatus="{{modestatus}}"></ts-read-mode>
            <ts-chunk-mode id="chunkmode" chunks="{{currentproject.chunks}}" modestatus="{{modestatus}}"></ts-chunk-mode>
            <ts-review-mode id="reviewmode" chunks="{{currentproject.chunks}}" modestatus="{{modestatus}}"></ts-review-mode>
            <ts-nosource-mode id="nosourcemode" projectmeta="[[currentproject.projectmeta]]"></ts-nosource-mode>
        </div>

        <paper-dialog id="checklistpopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Chunk Checklist</h2>
            <div>
                <p id="spaced">Are you sure you're Done with this chunk?</p>
                <p class$="[[versecheck(currentproject.projectmeta)]]">I have placed the verses correctly</p>
                <p>I have reviewed the words and meanings</p>
                <p class$="[[standardcheck(currentproject.projectmeta)]]">I have reviewed the translationQuestions</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>Cancel</paper-button>
                <paper-button dialog-confirm on-tap="closechecklist">Confirm</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="editpopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Edit Chunk</h2>
            <div>
                <p>This chunk is done. Continue editing?</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>Dismiss</paper-button>
                <paper-button dialog-confirm on-tap="closeedit">Edit</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="nodatapopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Missing Data</h2>
            <div>
                <p>All fields are not complete.</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>OK</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="printpopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Print</h2>
            <div>
                <p><span>[[currentproject.projectmeta.project.name]]</span> - <span>[[currentproject.projectmeta.target_language.name]]</span></p>
            </div>
            <div>
                <p><paper-checkbox id="imagebox"></paper-checkbox><span id="imagetext">Include images</span></p>
                <p><paper-checkbox id="chunkbox" checked="true"></paper-checkbox><span>Include incomplete chunks</span></p>
                 <p><paper-checkbox id="doublespacebox"></paper-checkbox><span>Double space text</span></p>
            </div>
            <div id="printbuttons">
                <paper-button dialog-dismiss>Cancel</paper-button>
                <paper-button on-tap="print">Save to PDF</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="delete" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2><iron-icon icon="delete"></iron-icon>Delete</h2>
            <div>
                <p>This will permanently remove this note/question. Continue?</p>
            </div>
            <div id="deletebuttons">
                <paper-button on-tap="closedelete">No</paper-button>
                <paper-button on-tap="deletehelp">Confirm</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="note" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Note</h2>
            <div id="notebody"></div>
            <div id="notebuttons">
                <paper-button dialog-dismiss>Dismiss</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="sourcepopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <ts-source-modal id="modal" on-close="closesource"></ts-source-modal>
        </paper-dialog>

        <paper-dialog id="loading" class="popup" modal="true" exit-animation="scale-down-animation">
            <ts-loading options="[[options]]"></ts-loading>
        </paper-dialog>

        <iron-signals on-iron-signal-frompublish="frompublish"></iron-signals>
        <iron-signals on-iron-signal-updatesources="updatesources"></iron-signals>
        <iron-signals on-iron-signal-loadproject="loadproject"></iron-signals>
        <iron-signals on-iron-signal-updatecompletion="updatecompletion"></iron-signals>
        <iron-signals on-iron-signal-openchecklist="openchecklist"></iron-signals>
        <iron-signals on-iron-signal-opendelete="opendelete"></iron-signals>
        <iron-signals on-iron-signal-openedit="openedit"></iron-signals>
        <iron-signals on-iron-signal-opennodata="opennodata"></iron-signals>
        <iron-signals on-iron-signal-opennote="opennote"></iron-signals>
        <iron-signals on-iron-signal-opensource="opensource"></iron-signals>
        <iron-signals on-iron-signal-savechunk="savechunk"></iron-signals>
        <iron-signals on-iron-signal-savemanifest="savemanifest"></iron-signals>
        <iron-signals on-iron-signal-updatestate="updatestate"></iron-signals>
        <iron-signals on-iron-signal-savestate="savestate"></iron-signals>
        <iron-signals on-iron-signal-reset="reset"></iron-signals>
        <iron-signals on-iron-signal-saveclose="saveAndClose"></iron-signals>
        <iron-signals on-iron-signal-saveall="saveAll"></iron-signals>

    </template>

</dom-module>

<script>

    Polymer({

        is: 'ts-translate',

        behaviors: [
            Polymer.IronResizableBehavior,
            Polymer.NeonAnimatableBehavior
        ],

        properties: {
            selected: {
                type: Number,
                value: 0,
                observer: 'modechange'
            },
            route: {
                type: String,
                value: '',
                notify: true
            },
            projectlist: {
                type: Array,
                value: []
            },
            currentproject: {
                type: Object,
                value: {},
                notify: true
            },
            currentuser: {
                type: Object,
                value: {}
            },
            modestatus: {
                type: Object,
                value: {}
            },
            options: {
                type: Object,
                value: {}
            },
            saveoptions: {
                type: Object,
                value: {chunks: [], manifest: false, backup: false}
            },
            savetimer: {
                type: Number
            },
            backuptimer: {
                type: Number
            },
            message: {
                type: String,
                value: "Idle",
                notify: true
            },
            animationConfig: {
                value: function () {
                    return {
                        'entry': {
                            name: 'slide-from-right-animation',
                            node: this
                        },
                        'exit': {
                            name: 'slide-right-animation',
                            node: this
                        }
                    }
                }
            }
        },

        starttimers: function () {
            var mythis = this;

            clearTimeout(mythis.savetimer);
            clearTimeout(mythis.backuptimer);

            mythis.savetimer = setTimeout(function timer1 () {
                mythis.saveAll();
                mythis.savetimer = setTimeout(timer1, 120000);
            }, 100);

            mythis.backuptimer = setTimeout(function timer2 () {
                mythis.set('saveoptions.backup', true);
                mythis.backuptimer = setTimeout(timer2, 590000);
            }, 100);
        },

        stoptimers: function () {
            clearTimeout(this.savetimer);
            clearTimeout(this.backuptimer);
        },

        saveAndClose: function () {
            if (this.route === "translate") {
                this.savestate();
                this.stoptimers();
                return this.saveAll()
                    .then(function () {
                        App.close();
                    });
            } else {
                App.close();
            }
        },

        saveAll: function () {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;
            var allchunks = mythis.currentproject.chunks;
            var filePath = App.configurator.getUserPath('datalocation', 'automatic_backups', projectmeta.unique_id + ".tstudio");
            var changes = false;
            var savechunks = mythis.saveoptions.chunks;

            var saveChunk = function (data) {
                var chunk = allchunks[data];
                return App.projectsManager.saveTargetChunk(chunk, projectmeta)
                    .catch(function (err) {
                        App.reporter.logError(err);
                    });
            };

            mythis.set('message', "Checking for Changes...");

            return Promise.resolve(true)
                .then(function () {
                    if (savechunks.length) {
                        changes = true;
                        mythis.addcontributor();
                        return Promise.all(_.map(savechunks, saveChunk))
                            .then(function () {
                                mythis.set('saveoptions.chunks', []);
                                return App.projectsManager.cleanProject(allchunks, projectmeta)
                                    .catch(function (err) {
                                        App.reporter.logError(err);
                                    });
                            });
                    }
                })
                .then(function () {
                    if (mythis.saveoptions.manifest) {
                        changes = true;
                        return App.projectsManager.saveTargetManifest(projectmeta)
                            .then(function () {
                                mythis.set('saveoptions.manifest', false);
                            })
                            .catch(function (err) {
                                App.reporter.logError(err);
                            });
                    }
                })
                .then(function () {
                    if (changes) {
                        return App.projectsManager.commitProject(projectmeta, mythis.currentuser)
                            .catch(function (err) {
                                App.reporter.logError(err);
                            });
                    }
                })
                .then(function () {
                    if (mythis.saveoptions.backup) {
                        return App.exportManager.backupTranslation(projectmeta, filePath)
                            .then(function () {
                                mythis.set('saveoptions.backup', false);
                            })
                            .catch(function (err) {
                                App.reporter.logError(err);
                            });
                    }
                })
                .then(function () {
                    if (changes) {
                        mythis.fire('iron-signal', {name: 'updatelist'});
                        mythis.set('message', "Changes Saved");
                    } else {
                        mythis.set('message', "No Changes Found");
                    }
                })
                .then(function () {
                    setTimeout(function() {
                        mythis.set('message', "Idle");
                    }, 1000);
                });

        },

        versecheck: function (data) {
            return data && data.project_type_class === "standard" && data.project.id !== "obs" ? '' : 'nodisplay';
        },

        standardcheck: function (data) {
            return data && data.project_type_class === "standard" ? '' : 'nodisplay';
        },

        opennodata: function () {
            this.$.nodatapopup.open();
        },

        opennote: function (event, data) {
            var text = data.text;
            this.$.note.open();
            this.$.notebody.innerHTML = text;
        },

        openchecklist: function (event, data) {
            this.modestatus.index = data.index;
            this.$.checklistpopup.open();
        },

        closechecklist: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'completechunk', data: {index: index}});
        },

        opendelete: function (event, data) {
            this.modestatus.index = data.index;
            this.$.delete.open();
        },

        closedelete: function () {
            this.$.delete.close();
        },

        deletehelp: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'deletehelp', data: {index: index}});
            this.closedelete();
        },

        openedit: function (event, data) {
            this.modestatus.index = data.index;
            this.$.editpopup.open();
        },

        closeedit: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'editchunk', data: {index: index}});
        },

        opensource: function () {
            var projectmeta = this.currentproject.projectmeta;
            var modal = this.$.modal;
            var sources = App.dataManager.getSources();
            var projectid = projectmeta.project.id;
            if (projectmeta.resource.id === "udb") {
                modal.allSources = _.filter(sources, {'project_id': projectid, 'checking_level': 3});
            } else {
                modal.allSources = _.filter(sources, function(source) {
                    return source.project_id === projectid && source.checking_level === 3 && source.resource_id !== "udb";
                });
            }
            modal.sources = projectmeta.source_translations;
            modal.selectedSource = projectmeta.currentsource;
            this.$.sourcepopup.open();
        },

        closesource: function () {
            this.$.sourcepopup.close();
        },

        forceResize: function () {
            this.$.readmode.notifyResize();
            this.$.chunkmode.notifyResize();
            this.$.reviewmode.notifyResize();
        },

        updatestate: function (event, data) {
            var id = data.id;
            var mode = data.mode;
            this.currentproject.statedata[id][mode] = data.value;
        },

        savestate: function () {
            if (this.route === "translate") {
                var key = this.currentproject.projectmeta.unique_id;
                this.getlocation();
                App.configurator.setValue(key + "-chapter", this.modestatus.chapter);
                App.configurator.setValue(key + "-index", this.modestatus.index);
                App.configurator.setValue(key + "-selected", this.selected);
            }
        },

        updatecompletion: function () {
            var key = this.currentproject.projectmeta.unique_id;
            var chunks = this.currentproject.chunks;
            var finished = [];

            for (var i = 0; i < chunks.length; i++) {
                if (chunks[i].completed) {
                    finished.push(chunks[i].chunkmeta.chapterid + "-" + chunks[i].chunkmeta.frameid);
                }
            }
            var completion = Math.round((finished.length / chunks.length) * 100);
            this.set('currentproject.projectmeta.finished_chunks', finished);
            this.set('currentproject.projectmeta.completion', completion);
            App.configurator.setValue(key + "-completion", completion);
            this.savemanifest();
        },

        savesource: function () {
            var key = this.currentproject.projectmeta.unique_id;
            var source = this.currentproject.projectmeta.currentsource;
            if (source !== null) {
                App.configurator.setValue(key + "-source", source);
            } else {
                App.configurator.unsetValue(key + "-source");
            }
        },

        retrievesource: function () {
            var key = this.currentproject.projectmeta.unique_id;
            var source = App.configurator.getValue(key + "-source");
            if (source && source < this.currentproject.projectmeta.source_translations.length) {
                this.set('currentproject.projectmeta.currentsource', source);
            }
        },

        loadproject: function (event, data) {
            var mythis = this;
            var type = data.type;
            var projectmeta = data.projectmeta;
            var list = this.projectlist;

            var loadsource = function () {
                if (projectmeta.project_type_class === "extant") {
                    mythis.createextantchunks();
                } else {
                    mythis.createchunks();
                    mythis.createchapters();
                }
                mythis.$.loading.close();
                setTimeout(function() {
                    mythis.setmodestate();
                    mythis.checksources();
                    mythis.starttimers();
                    if (type === "publish") {
                        setTimeout(function() {
                            mythis.gopublish();
                        }, 750);
                    }
                    if (type === "print") {
                        mythis.goprint();
                    }
                }, 250);
            };

            var loadwords = function () {
                if (projectmeta.project_type_class !== "extant") {
                    var wordmeta = false;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].target_language.id === projectmeta.target_language.id && list[i].type.id === "tw") {
                            wordmeta = list[i];
                        }
                    }
                    if (wordmeta) {
                        App.projectsManager.loadTargetTranslation(wordmeta).then(function (words) {
                            mythis.set('currentproject.rawdata.words', words);
                            loadsource();
                        });
                    } else {
                        mythis.set('currentproject.rawdata.words', {});
                        loadsource();
                    }
                } else {
                    mythis.set('currentproject.rawdata.words', {});
                    loadsource();
                }
            };

            var loaddata2 = function () {
                if (projectmeta.project_type_class === "helps") {
                    var secondmeta = false;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].project.id === projectmeta.project.id && list[i].target_language.id === projectmeta.target_language.id && (list[i].resource.id === "ulb" || list[i].resource.id === "obs")) {
                            secondmeta = list[i];
                        }
                    }
                    if (!secondmeta) {
                        for (i = 0; i < list.length; i++) {
                            if (list[i].project.id === projectmeta.project.id && list[i].target_language.id === projectmeta.target_language.id && (list[i].resource.id === "udb" || list[i].resource.id === "reg")) {
                                secondmeta = list[i];
                            }
                        }
                    }
                    if (secondmeta) {
                        App.projectsManager.loadTargetTranslation(secondmeta).then(function (secondtranslation) {
                            mythis.set('currentproject.rawdata.second', secondtranslation);
                            loadwords();
                        });
                    } else {
                        mythis.set('currentproject.rawdata.second', {});
                        loadwords();
                    }
                } else {
                    mythis.set('currentproject.rawdata.second', {});
                    loadwords();
                }
            };

            this.setrightanimation();
            mythis.set('currentproject.projectmeta', projectmeta);
            mythis.set('currentproject.statedata', {});
            mythis.set('currentproject.rawdata', {});
            mythis.retrievesource();
            this.route = "translate";
            setTimeout(function() {
                mythis.set('options', {});
                mythis.set('options.body', "Loading project. Please wait...");
                mythis.set('options.loading', true);
                mythis.$.loading.open();
                setTimeout(function() {
                    return App.projectsManager.loadTargetTranslation(projectmeta)
                        .then(function (translation) {
                            mythis.set('currentproject.rawdata.main', translation);
                            loaddata2();
                        })
                        .catch(function(err) {
                            App.reporter.logError(err);
                            var errmessage = "An error occurred while trying to load this project";
                            if(err !== null) {
                                errmessage += "\n" + err;
                            }
                            mythis.set('options.title', "Project Load Failed");
                            mythis.set('options.body', errmessage);
                            mythis.set('options.loading', false);
                        });
                }, 250);
            }, 500);
        },

        updatesources: function (event, data) {
            var mythis = this;
            mythis.set('options', {});
            mythis.set('options.body', "Loading source. Please wait...");
            mythis.set('options.loading', true);
            mythis.$.loading.open();
            setTimeout(function() {
                mythis.set('currentproject.projectmeta.source_translations', data.sources);
                mythis.set('currentproject.projectmeta.currentsource', data.selected);
                mythis.savemanifest();
                mythis.savesource();
                mythis.getlocation();
                mythis.reloaddata(data.full);
            }, 250);
        },

        reloaddata: function (full) {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;

            App.projectsManager.loadTargetTranslation(projectmeta)
                .then(function (translation) {
                    mythis.set('currentproject.rawdata.main', translation);
                    mythis.createchunks();
                    mythis.createchapters();
                    mythis.$.loading.close();
                    mythis.forceResize();
                    mythis.setlocation();
                    if (full) {
                        mythis.checksources();
                    }
                });
        },

        savechunk: function (event, data) {
            if (this.saveoptions.chunks.indexOf(data.chunk.index) < 0) {
                this.push('saveoptions.chunks', data.chunk.index);
            }
            this.createchapters();
        },

        savemanifest: function () {
            this.set('saveoptions.manifest', true);
        },

        addcontributor: function () {
            var user = this.currentuser.full_name;
            var array = this.currentproject.projectmeta.translators;
            if (array.indexOf(user) === -1) {
                this.push('currentproject.projectmeta.translators', user);
                this.savemanifest();
            }
        },

        createchunks: function () {
            var projectmeta = this.currentproject.projectmeta;
            var current = projectmeta.currentsource;
            if (current === null || current === undefined) {
                return;
            }
            var currentsource = projectmeta.source_translations[current];
            var frames = App.dataManager.getSourceFrames(currentsource);
            var chunkarray = [];
            var index = 0;

            for (var i = 0; i < frames.length; i++) {
                if (frames[i].verse === "00") {
                    frames.push(frames.splice(i, 1)[0]);
                    i = frames.length;
                }
            }

            for (i = 0; i < frames.length; i++) {
                var resources = this.getFrameResources(frames[i], currentsource);
                var sourcedata = App.renderer.convertVerseMarkers(frames[i].chunk);
                var chunkmeta = this.createFrameMeta(frames[i], projectmeta, sourcedata.verses);
                var chunk = this.getFrameData(chunkmeta, projectmeta);
                var sourcecontent = App.renderer.convertNoteMarkers(sourcedata.text);
                chunk.srccontent = App.renderer.renderSourceWithVerses(sourcecontent);
                chunk.wordcontent = "";
                chunk.resources = resources;
                if (projectmeta.project_type_class === "standard" && chunkmeta.frameid === "01") {
                    if (chunkmeta.chapterid === "01") {
                        chunkarray.push(this.createProjectTitleFrame(chunkmeta, projectmeta, index));
                        index++;
                    }
                    if (chunkmeta.title) {
                        chunkarray.push(this.createChapterTitleFrame(chunkmeta, projectmeta, index));
                        index++;
                    }
                    if (chunkmeta.reference) {
                        chunkarray.push(this.createChapterRefFrame(chunkmeta, projectmeta, index));
                        index++;
                    }
                }
                chunk.index = index;
                chunkarray.push(chunk);
                index++;
            }
            this.set('currentproject.chunks', chunkarray);
        },

        createchapters: function () {
            var projectmeta = this.currentproject.projectmeta;
            var current = projectmeta.currentsource;
            if (current === null || current === undefined || projectmeta.project_type_class !== "standard") {
                return;
            }
            var chunks = this.currentproject.chunks;
            var mythis = this;
            var chapters = [];

            _.forEach(_.groupBy(chunks, function(chunk) {
                return chunk.chunkmeta.chapter;
            }), function (data, chap) {
                var chapcomplete = true;
                var transcontent = "";
                var srccontent = "";
                var chaptermeta = {};

                _.forEach(data, function (chunk) {
                    if (chunk.chunkmeta.frame > 0) {
                        if (!chunk.completed) {
                            chapcomplete = false;
                        }
                        transcontent += chunk.transcontent + " ";
                        srccontent += chunk.srccontent + " ";
                        chaptermeta = chunk.chunkmeta;
                    }
                });
                var statedata = mythis.currentproject.statedata[chaptermeta.chapterid];
                if (!statedata) {
                    statedata = {read: true};
                    mythis.currentproject.statedata[chaptermeta.chapterid] = statedata;
                }
                if (chaptermeta.chapter > 0) {
                    chapters.push({completed: chapcomplete, transcontent: transcontent, srccontent: srccontent, projectmeta: _.cloneDeep(projectmeta), chaptermeta: chaptermeta, state: statedata});
                }
            });
            this.set('currentproject.chapters', chapters);
        },

        createextantchunks: function () {
            var projectmeta = this.currentproject.projectmeta;
            var type = projectmeta.type.id;
            var language = projectmeta.target_language.name;
            var frames;
            var volume = "vol1";
            var chunkarray = [];
            var sources = App.dataManager.getSources();
            var filtered = _.filter(sources, {'language_id': "en", 'resource_id': "ulb", 'checking_level': 3});

            if (type === "tw") {
                frames = App.dataManager.getAllWords(filtered[0]);
            } else if (type === "ta") {
                if (projectmeta.project.id !== "ta") {
                    volume = projectmeta.project.id;
                }
                frames = App.dataManager.getTa(volume);
            }

            for (var i = 0; i < frames.length; i++) {
                var chunkmeta = {
                    chapterid: "01",
                    chapter: 1,
                    frameid: frames[i].slug,
                    verses: [],
                    chunkref: frames[i].title,
                    refaddon: " — " + language
                };
                var chunk = this.getFrameData(chunkmeta, projectmeta);
                chunk.srccontent = frames[i].body;
                chunk.wordcontent = frames[i].title;
                chunk.resources = [];
                chunk.index = i;
                chunkarray.push(chunk);
            }
            this.set('currentproject.chunks', chunkarray);
        },

        getFrameResources: function (frame, currentsource) {
            var notes = App.dataManager.getFrameNotes(frame.id);
            var words = App.dataManager.getFrameWords(frame.id);
            var questions = App.dataManager.getFrameQuestions(frame.id);
            var udbtext = null;
            var resources = [];

            for (var n = 0; n < notes.length; n++) {
                if (notes[n].title === "") {
                    notes[n].title = notes[n].body;
                }
            }
            for (var w = 0; w < words.length; w++) {
                var worddata = this.currentproject.rawdata.words["01-" + words[w].slug];
                if (worddata && worddata.helpscontent[0].body !== "" && worddata.helpscontent[0].title !== "") {
                    words[w].title = worddata.helpscontent[0].title;
                    words[w].body = worddata.helpscontent[0].body;
                }
            }
            if (notes.length) {
                resources.push({title: "Notes", array: true, data: notes});
            }
            if (words.length) {
                resources.push({title: "Words", array: true, data: words});
            }
            if (questions.length) {
                resources.push({title: "Questions", array: true, data: questions});
            }
            if (currentsource.resource_id === "ulb") {
                var result = App.dataManager.getFrameUdb(currentsource, frame.chapter, frame.verse)[0];
                if (result) {
                    udbtext = App.renderer.convertVerseMarkers(result.chunk).text;
                    udbtext = App.renderer.renderSourceWithVerses(udbtext);
                    resources.push({title: "UDB", array: false, data: [udbtext]});
                }
            }
            return resources;
        },

        createFrameMeta: function (frame, projectmeta, verses) {
            var refaddon = projectmeta.target_language.name;
            var resource = projectmeta.resource.id;
            var name = projectmeta.project.name;
            var chapterid = frame.chapter;
            var chapternum = parseInt(chapterid);
            var frameid = frame.verse;
            var framenum = parseInt(frameid);
            var title = frame.title;
            var reference = frame.reference;
            var chapterref;
            var chunkref;

            if (resource === "ulb" || resource === "udb") {
                refaddon += " (" + resource + ")";
            }
            if (framenum === 0) {
                framenum = verses[0];
                frameid = framenum.toString();
                if (frameid.length === 1) {
                    frameid = "0" + frameid;
                }
            }
            if (name === "Open Bible Stories") {
                chapterref = title;
                chunkref = title + ":" + framenum;
            } else {
                chapterref = name + " " + chapternum;
                chunkref = name + " " + chapternum + ":" + verses[0] + "–" + verses[verses.length-1];
            }

            return {
                chapter: chapternum,
                frame: framenum,
                title: title,
                reference: reference,
                chapterid: chapterid,
                frameid: frameid,
                verses: verses,
                chapterref: chapterref,
                chunkref: chunkref,
                refaddon: " — " + refaddon
            };
        },

        getFrameData: function (chunkmeta, projectmeta) {
            var typeclass = projectmeta.project_type_class;
            var complexid = chunkmeta.chapterid + '-' + chunkmeta.frameid;
            var verses = chunkmeta.verses;
            var maindata = this.currentproject.rawdata.main[complexid];
            var seconddata = this.currentproject.rawdata.second[complexid];
            var statedata = this.currentproject.statedata[complexid];
            var completed = false;
            var transcontent = "";
            var helpscontent = [];

            if (typeclass === "extant") {
                helpscontent = [{title: "", body: ""}];
            }

            if (maindata) {
                completed = projectmeta.finished_chunks.indexOf(complexid) >= 0;
                if (typeclass === "standard") {
                    transcontent = App.renderer.convertVerseMarkers(maindata.transcontent).text;
                    transcontent = App.renderer.migrateMarkers(transcontent);
                    transcontent = App.renderer.removeChapterMarkers(transcontent);
                    transcontent = App.renderer.validateVerseMarkers(transcontent, verses);
                } else {
                    helpscontent = maindata.helpscontent;
                }
            }
            if (seconddata && typeclass === "helps") {
                transcontent = seconddata.transcontent;
                transcontent = App.renderer.migrateMarkers(transcontent);
                transcontent = App.renderer.removeChapterMarkers(transcontent);
            }
            if (!statedata) {
                statedata = {chunk: true, review: true, resource: 0};
                this.currentproject.statedata[complexid] = statedata;
            }
            return {projectmeta: _.cloneDeep(projectmeta), chunkmeta: chunkmeta, transcontent: transcontent, helpscontent: helpscontent, completed: completed, state: statedata};
        },

        createProjectTitleFrame: function (chunkmeta, projectmeta, index) {
            var titlemeta = {
                chapter: 0,
                frame: 0,
                chapterid: "00",
                frameid: "title",
                chunkref: "Project Title",
                refaddon: chunkmeta.refaddon,
                verses: []
            };
            var chunk = this.getFrameData(titlemeta, projectmeta);
            chunk.projectmeta = projectmeta;
            chunk.chunkmeta = titlemeta;
            chunk.srccontent = projectmeta.project.name;
            chunk.wordcontent = "";
            chunk.resources = [];
            chunk.index = index;
            return chunk;
        },

        createChapterTitleFrame: function (chunkmeta, projectmeta, index) {
            var titlemeta = {
                chapter: chunkmeta.chapter,
                frame: 0,
                title: chunkmeta.title,
                reference: chunkmeta.reference,
                chapterid: chunkmeta.chapterid,
                frameid: "title",
                verses: [],
                chunkref: "Story Title",
                refaddon: chunkmeta.refaddon
            };
            var chunk = this.getFrameData(titlemeta, projectmeta);
            chunk.projectmeta = projectmeta;
            chunk.chunkmeta = titlemeta;
            chunk.srccontent = chunkmeta.title;
            chunk.wordcontent = "";
            chunk.resources = [];
            chunk.index = index;
            return chunk;
        },

        createChapterRefFrame: function (chunkmeta, projectmeta, index) {
            var refmeta = {
                chapter: chunkmeta.chapter,
                frame: 0,
                title: chunkmeta.title,
                reference: chunkmeta.reference,
                chapterid: chunkmeta.chapterid,
                frameid: "reference",
                verses: [],
                chunkref: "Story Reference",
                refaddon: chunkmeta.refaddon
            };
            var chunk = this.getFrameData(refmeta, projectmeta);
            chunk.projectmeta = projectmeta;
            chunk.chunkmeta = refmeta;
            chunk.srccontent = chunkmeta.reference;
            chunk.wordcontent = "";
            chunk.resources = [];
            chunk.index = index;
            return chunk;
        },

        modechange: function (tomode, frommode) {
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;
            var nosource = this.$.nosourcemode;

            if (frommode > 0) {
                this.set('modestatus.lastmode', frommode);
            }

            if (frommode === 1) {
                read.frommode();
            } else if (frommode === 2) {
                chunk.frommode();
            } else if (frommode === 3) {
                review.frommode();
            } else if (frommode === 4) {
                nosource.frommode();
            }

            if (tomode === 1) {
                read.tomode();
            } else if (tomode === 2) {
                chunk.tomode();
            } else if (tomode === 3) {
                review.tomode();
            } else if (tomode === 4) {
                nosource.tomode();
            }
        },

        reset: function () {
            var mythis = this;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;
            var nosource = this.$.nosourcemode;

            mythis.set('selected', 0);
            mythis.set('modestatus', {"chapter": 1, "lastmode": 1, "index": -1});
            read.classList.add("hide");
            chunk.classList.add("hide");
            review.classList.add("hide");
            nosource.classList.add("hide");
        },

        setmodestate: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var sources = projectmeta.source_translations;
            var key = projectmeta.unique_id;
            var index = App.configurator.getValue(key + "-index");
            var chapter = App.configurator.getValue(key + "-chapter");
            var selected = App.configurator.getValue(key + "-selected");
            var typeclass = projectmeta.project_type_class;

            if (chapter > 0) {
                mythis.set('modestatus.chapter', chapter);
            }
            if (index >= 0) {
                mythis.set('modestatus.index', index);
            }
            if (typeclass === "standard") {
                mythis.set('modestatus.lastmode', 1);
            } else {
                mythis.set('modestatus.lastmode', 3);
            }

            if ((sources !== undefined && sources.length !== 0) || typeclass === "extant") {
                setTimeout(function() {
                    if (selected > 0) {
                        mythis.set('selected', selected);
                    } else {
                        if (typeclass === "standard") {
                            mythis.set('selected', 1);
                        } else {
                            mythis.set('selected', 3);
                        }
                    }
                }, 500);
            }
        },

        checksources: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var sources = projectmeta.source_translations;
            var lastmode = this.modestatus.lastmode;
            var selected = this.selected;
            var typeclass = projectmeta.project_type_class;

            if (selected === 4) {
                if (sources !== undefined && sources.length !== 0) {
                    mythis.set('selected', lastmode);
                }
            } else {
                if ((sources === undefined || sources.length === 0) && typeclass !== "extant") {
                    setTimeout(function() {
                        mythis.set('selected', 4);
                    }, 500);
                }
            }
        },

        getlocation: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;

            if (selected === 1) {
                read.getlocation();
            } else if (selected === 2) {
                chunk.getlocation();
            } else if (selected === 3) {
                review.getlocation();
            }
        },

        setlocation: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;

            if (selected === 1) {
                read.setlocation();
            } else if (selected === 2) {
                chunk.setlocation();
            } else if (selected === 3) {
                review.setlocation();
            }
        },

        setheights: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;

            if (selected === 1) {
                read.setheights();
            } else if (selected === 2) {
                chunk.setheights();
            }
        },

        frompublish: function (event, data) {
            var mythis = this;
            this.selected = 0;
            this.set('modestatus.index', data.index);
            this.route = "translate";
            setTimeout(function() {
                mythis.selected = 3;
            }, 500);
        },

        gohome: function () {
            var mythis = this;
            mythis.savestate();
            mythis.stoptimers();
            return mythis.saveAll()
                .then(function () {
                    mythis.set('route', "home");
                    mythis.reset();
                });
        },

        gopublish: function () {
            var mythis = this;
            var typeclass = mythis.currentproject.projectmeta.project_type_class;
            if(mythis.currentproject.projectmeta.source_translations.length || typeclass === "extant") {
                mythis.set('options', {});
                mythis.set('options.body', "Loading upload page. Please wait...");
                mythis.set('options.loading', true);
                mythis.$.loading.open();
                setTimeout(function() {
                    mythis.savestate();
                    mythis.setleftanimation();
                    mythis.stoptimers();
                    return mythis.saveAll()
                        .then(function () {
                            mythis.fire('iron-signal', {name: 'updatepublish'});
                            mythis.$.loading.close();
                            mythis.set('route', "publish");
                        });
                }, 250);
            }
        },

        goprint: function () {
            this.$.chunkbox.checked = true;
            this.$.imagebox.checked = false;
            this.$.doublespacebox.checked = false;
            var project = this.currentproject.projectmeta.project.id;
            if (project === 'obs') {
                this.$.imagebox.hidden = false;
                this.$.imagetext.hidden = false;
            } else {
                this.$.imagebox.hidden = true;
                this.$.imagetext.hidden = true;
            }
            this.$.printpopup.open();
        },

        gobackup: function () {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;
            mythis.stoptimers();
            return mythis.saveAll()
                .then(function () {
                    mythis.fire('iron-signal', {name: 'openbackup', data: {projectmeta: projectmeta}});
                    mythis.starttimers();
                });
        },

        gosettings: function () {
            this.savestate();
            this.setleftanimation();
            App.configurator.setValue("backto", this.route);
            this.route = "settings";
        },

        print: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var translation = this.currentproject.chunks;
            var name = this.currentproject.projectmeta.unique_id;
            var options = {includeIncompleteFrames: this.$.chunkbox.checked, includeImages: this.$.imagebox.checked, doubleSpace: this.$.doublespacebox.checked};
            var filePath = App.ipc.sendSync('save-as', {options: {defaultPath: name, filters: [{name: 'PDF Files', extensions: ['pdf']}]}});
            if (!filePath) {
                return;
            }
            var generatePdf = function(){
                mythis.set('options.body', "Creating PDF. Please wait...");
                setTimeout(function() {
                    return App.printManager.targetTranslationToPdf(translation, projectmeta, filePath, options)
                        .then(function () {
                            mythis.set('options.title', "PDF Created");
                            mythis.set('options.body', "Your project has been successfully saved to a PDF.");
                            mythis.set('options.loading', false);
                        })
                        .catch(function (err) {
                            var errmessage = "An error occurred saving your project";
                            if(err !== null) {
                                errmessage += "\n" + err;
                            }
                            mythis.set('options.title', "Print Failed");
                            mythis.set('options.body', errmessage);
                            mythis.set('options.loading', false);
                        });
                }, 500);
            };

            mythis.$.printpopup.close();
            mythis.set('options', {});
            mythis.set('options.loading', true);
            mythis.$.loading.open();

            if (options.includeImages) {
                mythis.set('options.body', "Downloading Images. Please wait...");
                App.printManager.downloadImages().then(function(){
                    mythis.set('options.body', "Extracting Images. Please wait...");
                    App.printManager.extractImages();
                    generatePdf();
                }).catch(function(err){
                    var errmessage = "An error occurred while downloading images";
                    if(err !== null) {
                        errmessage += "\n" + err;
                    }
                    mythis.set('options.title', "Download Failed");
                    mythis.set('options.body', errmessage);
                    mythis.set('options.loading', false);
                });
            } else {
                generatePdf();
            }
        },

        setrightanimation: function () {
            this.animationConfig.exit.name = 'slide-right-animation';
            this.animationConfig.entry.name = 'slide-from-right-animation';
        },

        setleftanimation: function () {
            this.animationConfig.exit.name = 'slide-left-animation';
            this.animationConfig.entry.name = 'slide-from-left-animation';
        },

        ready: function() {
            var mythis = this;
            this.reset();
            window.addEventListener("resize", function () {
                mythis.getlocation();
                mythis.setlocation();
                mythis.setheights();
            });
        }

    });

</script>
