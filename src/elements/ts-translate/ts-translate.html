
<link rel="import" href="../../components/iron-signals/iron-signals.html">
<link rel="import" href="../../components/paper-dialog/paper-dialog.html">
<link rel="import" href="../../components/paper-button/paper-button.html">
<link rel="import" href="../../components/neon-animation/neon-animation.html">
<link rel="import" href="../../components/paper-checkbox/paper-checkbox.html">

<link rel="import" href="./ts-read-mode/ts-read-mode.html">
<link rel="import" href="./ts-chunk-mode/ts-chunk-mode.html">
<link rel="import" href="./ts-review-mode/ts-review-mode.html">
<link rel="import" href="./ts-conflict-mode/ts-conflict-mode.html">
<link rel="import" href="./ts-translate-sidebar.html">
<link rel="import" href="./ts-nosource-mode.html">
<link rel="import" href="./ts-source/ts-source-modal.html">

<dom-module id="ts-translate">

    <style>

        :host {
            display: flex;
        }

        #pages {
            flex: auto;
            display: flex;
            position: relative;
        }

        .popup {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            margin: auto;
        }

        #checklistpopup {
            width: 350px;
            height: 225px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #checklistpopup p {
            margin: 0;
        }

        #checklistpopup p#spaced {
            margin-bottom: 15px;
        }

        #checklistpopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #checklistpopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #editpopup {
            width: 350px;
            height: 175px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #editpopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #editpopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #sourcepopup {
            height: 500px;
            width: 500px;
            display: flex;
        }

        #sourcepopup * {
            margin: 0;
            padding: 0;
        }

        #nodatapopup {
            width: 300px;
            height: 175px;
            text-align: center;
            color: var(--primary-text-color);
        }

        #nodatapopup .buttons {
            display: flex;
            justify-content: center;
            color: var(--secondary-text-color);
        }

        #nodatapopup .buttons paper-button:hover {
            color: var(--accent-color);
        }

        #delete {
            width: 450px;
            height: 175px;
        }

        #delete iron-icon {
            padding-right: 10px;
        }

        #delete p {
            font-size: 110%;
        }

        #deletebuttons {
            display: flex;
            justify-content: flex-end;
            padding: 0 50px;
            color: var(--secondary-text-color);
        }

        #deletebuttons paper-button:hover {
            color: var(--accent-color);
        }

        #note {
            width: 350px;
            height: 250px;
        }

        #notebuttons {
            display: flex;
            justify-content: flex-end;
            padding: 0 50px;
            color: var(--secondary-text-color);
        }

        #notebuttons paper-button:hover {
            color: var(--accent-color);
        }

        .nodisplay {
            display: none;
        }

    </style>

    <template>

        <ts-translate-sidebar selected="{{selected}}" currentproject="[[currentproject]]" on-gohome="gohome" on-goreview="goreview" on-goexport="goexport" on-goprint="goprint" on-gosearch="gosearch" on-gosettings="gosettings"></ts-translate-sidebar>

        <div id="pages">
            <ts-read-mode id="readmode" chapters="[[currentproject.chapters]]" modestatus="{{modestatus}}"></ts-read-mode>
            <ts-chunk-mode id="chunkmode" chunks="{{currentproject.chunks}}" modestatus="{{modestatus}}"></ts-chunk-mode>
            <ts-review-mode id="reviewmode" chunks="{{currentproject.chunks}}" modestatus="{{modestatus}}"></ts-review-mode>
            <ts-nosource-mode id="nosourcemode" projectmeta="[[currentproject.projectmeta]]"></ts-nosource-mode>
            <ts-conflict-mode id="conflictmode" chunks="{{currentproject.chunks}}" modestatus="{{modestatus}}"></ts-conflict-mode>
        </div>

        <paper-dialog id="checklistpopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Chunk Checklist</h2>
            <div>
                <p id="spaced">Are you sure you're Done with this chunk?</p>
                <p class$="[[versecheck(currentproject.projectmeta)]]">I have placed the verses correctly</p>
                <p>I have reviewed the words and meanings</p>
                <p class$="[[standardcheck(currentproject.projectmeta)]]">I have reviewed the translationQuestions</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>Cancel</paper-button>
                <paper-button dialog-confirm on-tap="closechecklist">Confirm</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="editpopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Edit Chunk</h2>
            <div>
                <p>This chunk is done. Continue editing?</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>Dismiss</paper-button>
                <paper-button dialog-confirm on-tap="closeedit">Edit</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="nodatapopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Missing Data</h2>
            <div>
                <p>All fields are not complete.</p>
            </div>
            <div class="buttons">
                <paper-button dialog-dismiss>OK</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="delete" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2><iron-icon icon="delete"></iron-icon>Delete</h2>
            <div>
                <p>This will permanently remove this note/question. Continue?</p>
            </div>
            <div id="deletebuttons">
                <paper-button on-tap="closedelete">Cancel</paper-button>
                <paper-button on-tap="deletehelp">Confirm</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="note" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <h2>Note</h2>
            <div id="notebody"></div>
            <div id="notebuttons">
                <paper-button dialog-dismiss>Dismiss</paper-button>
            </div>
        </paper-dialog>

        <paper-dialog id="sourcepopup" class="popup" modal="true" entry-animation="scale-up-animation" exit-animation="scale-down-animation">
            <ts-source-modal id="modal" on-close="closesource" options="{{options}}"></ts-source-modal>
        </paper-dialog>

        <iron-signals on-iron-signal-fromreview="fromreview"></iron-signals>
        <iron-signals on-iron-signal-updatesources="updatesources"></iron-signals>
        <iron-signals on-iron-signal-loadproject="loadproject"></iron-signals>
        <iron-signals on-iron-signal-updatecompletion="updatecompletion"></iron-signals>
        <iron-signals on-iron-signal-openchecklist="openchecklist"></iron-signals>
        <iron-signals on-iron-signal-opendelete="opendelete"></iron-signals>
        <iron-signals on-iron-signal-openedit="openedit"></iron-signals>
        <iron-signals on-iron-signal-opennodata="opennodata"></iron-signals>
        <iron-signals on-iron-signal-opennote="opennote"></iron-signals>
        <iron-signals on-iron-signal-opensource="opensource"></iron-signals>
        <iron-signals on-iron-signal-savechunk="savechunk"></iron-signals>
        <iron-signals on-iron-signal-savemanifest="savemanifest"></iron-signals>
        <iron-signals on-iron-signal-updatestate="updatestate"></iron-signals>
        <iron-signals on-iron-signal-savestate="savestate"></iron-signals>
        <iron-signals on-iron-signal-reset="reset"></iron-signals>
        <iron-signals on-iron-signal-saveclose="saveAndClose"></iron-signals>
        <iron-signals on-iron-signal-saveall="saveAll"></iron-signals>
        <iron-signals on-iron-signal-gotoreview="goToReview"></iron-signals>
        <iron-signals on-iron-signal-resolveconflict="resolveConflict"></iron-signals>
        <iron-signals on-iron-signal-translateright="setrightanimation"></iron-signals>
        <iron-signals on-iron-signal-translateleft="setleftanimation"></iron-signals>

    </template>

</dom-module>

<script>

    Polymer({

        is: 'ts-translate',

        behaviors: [
            Polymer.IronResizableBehavior,
            Polymer.NeonAnimatableBehavior
        ],

        properties: {
            selected: {
                type: Number,
                value: 0,
                observer: 'modechange'
            },
            route: {
                type: String,
                value: '',
                notify: true,
                observer: 'load'
            },
            projectlist: {
                type: Array,
                value: []
            },
            currentproject: {
                type: Object,
                value: {},
                notify: true
            },
            currentuser: {
                type: Object,
                value: {}
            },
            modestatus: {
                type: Object,
                value: {}
            },
            options: {
                type: Object,
                value: {},
                notify: true
            },
            saveoptions: {
                type: Object,
                value: {chunks: [], manifest: false, backup: false}
            },
            savetimer: {
                type: Number
            },
            backuptimer: {
                type: Number
            },
            message: {
                type: String,
                value: "Idle",
                notify: true
            },
            animationConfig: {
                value: function () {
                    return {
                        'entry': {
                            name: 'slide-from-right-animation',
                            node: this
                        },
                        'exit': {
                            name: 'slide-right-animation',
                            node: this
                        }
                    }
                }
            }
        },

        starttimers: function () {
            var mythis = this;

            clearTimeout(mythis.savetimer);
            clearTimeout(mythis.backuptimer);

            mythis.savetimer = setTimeout(function timer1 () {
                mythis.saveAll();
                mythis.savetimer = setTimeout(timer1, 120000);
            }, 100);

            mythis.backuptimer = setTimeout(function timer2 () {
                mythis.set('saveoptions.backup', true);
                mythis.backuptimer = setTimeout(timer2, 590000);
            }, 100);
        },

        stoptimers: function () {
            clearTimeout(this.savetimer);
            clearTimeout(this.backuptimer);
        },

        goToReview: function (event, data) {
            this.set('selected', 0);
            this.set('modestatus.index', data.index);
            this.set('modestatus.chapter', data.chapter);
            this.set('selected', 3);
        },

        saveAndClose: function () {
            if (this.route === "translate") {
                this.savestate();
                this.stoptimers();
                return this.saveAll()
                    .then(function () {
                        App.close();
                    });
            } else {
                App.close();
            }
        },

        saveAll: function () {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;
            var allchunks = mythis.currentproject.chunks;
            var filePath = App.configurator.getUserPath('datalocation', 'automatic_backups', projectmeta.unique_id + ".tstudio");
            var changes = false;
            var savechunks = mythis.saveoptions.chunks;

            var saveChunk = function (data) {
                var chunk = allchunks[data];
                return App.projectsManager.saveTargetChunk(chunk, projectmeta)
                    .catch(function (err) {
                        App.reporter.logError(err, 'Error saving chunk');
                    });
            };

            mythis.set('message', "Checking for Changes...");

            return Promise.resolve(true)
                .then(function () {
                    if (savechunks.length) {
                        changes = true;
                        mythis.addcontributor();
                        return Promise.all(_.map(savechunks, saveChunk))
                            .then(function () {
                                mythis.set('saveoptions.chunks', []);
                                return App.projectsManager.cleanProject(allchunks, projectmeta)
                                    .catch(function (err) {
                                        App.reporter.logError(err, 'Error cleaning project');
                                    });
                            });
                    }
                })
                .then(function () {
                    if (mythis.saveoptions.manifest) {
                        changes = true;
                        return App.projectsManager.saveTargetManifest(projectmeta)
                            .then(function () {
                                mythis.set('saveoptions.manifest', false);
                            })
                            .catch(function (err) {
                                App.reporter.logError(err, 'Error saving target manifest');
                            });
                    }
                })
                .then(function () {
                    if (changes) {
                        return App.projectsManager.commitProject(projectmeta, mythis.currentuser)
                            .catch(function (err) {
                                App.reporter.logError(err, 'Error committing project');
                            });
                    }
                })
                .then(function () {
                    if (mythis.saveoptions.backup) {
                        return App.exportManager.autoBackupTranslation(projectmeta, filePath)
                            .then(function () {
                                mythis.set('saveoptions.backup', false);
                            })
                            .catch(function (err) {
                                mythis.set('options', {});
                                mythis.set('options.title', "Auto Backup Failed");
                                mythis.set('options.body', err);
                                mythis.set('options.loading', false);
                                mythis.fire('iron-signal', {name: 'openloading'});
                                mythis.set('saveoptions.backup', false);
                                App.reporter.logError(err, 'Error backing up translation');
                            });
                    }
                })
                .then(function () {
                    if (changes) {
                        mythis.fire('iron-signal', {name: 'updatelist'});
                        mythis.set('message', "Changes Saved");
                    } else {
                        mythis.set('message', "No Changes Found");
                    }
                })
                .then(function () {
                    setTimeout(function() {
                        mythis.set('message', "Idle");
                    }, 1000);
                });

        },

        versecheck: function (data) {
            return data && data.project_type_class === "standard" && data.project.id !== "obs" ? '' : 'nodisplay';
        },

        standardcheck: function (data) {
            return data && data.project_type_class === "standard" ? '' : 'nodisplay';
        },

        opennodata: function () {
            this.$.nodatapopup.open();
        },

        opennote: function (event, data) {
            var text = data.text;
            this.$.note.open();
            this.$.notebody.innerHTML = text;
        },

        openchecklist: function (event, data) {
            this.modestatus.index = data.index;
            this.$.checklistpopup.open();
        },

        closechecklist: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'completechunk', data: {index: index}});
        },

        opendelete: function (event, data) {
            this.modestatus.index = data.index;
            this.$.delete.open();
        },

        closedelete: function () {
            this.$.delete.close();
        },

        deletehelp: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'deletehelp', data: {index: index}});
            this.closedelete();
        },

        openedit: function (event, data) {
            this.modestatus.index = data.index;
            this.$.editpopup.open();
        },

        closeedit: function () {
            var index = this.modestatus.index;
            this.fire('iron-signal', {name: 'editchunk', data: {index: index}});
        },

        opensource: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var modal = this.$.modal;
            var selected = [];
            var available = [];

            mythis.set('options', {});
            mythis.set('options.body', "Loading source options. Please wait...");
            mythis.set('options.loading', true);
            mythis.fire('iron-signal', {name: 'openloading'});

            App.dataManager.getSourcesByProject(projectmeta.project.id)
                .then(function (sources) {
                    if (projectmeta.resource.id !== "udb") {
                        sources = _.filter(sources, function(source) {
                            return source.resource_id !== "udb";
                        });
                    }

                    sources.forEach(function (source) {
                        var inarray = false;
                        projectmeta.source_translations.forEach(function (current) {
                            if (current.unique_id === source.unique_id) {
                                inarray = true;
                            }
                        });
                        if (inarray) {
                            selected.push(source);
                        } else {
                            available.push(source);
                        }
                    });

                    modal.set('selected', modal.sortlist(selected));
                    modal.set('available', modal.sortlist(available));
                    modal.searchfilter();
                    mythis.fire('iron-signal', {name: 'closeloading'});
                    setTimeout(function() {
                        mythis.$.sourcepopup.open();
                    }, 500);
                });
        },

        closesource: function () {
            this.$.sourcepopup.close();
        },

        load: function (route) {
            if (route === "translate") {
                this.forceResize();
            }
        },

        forceResize: function () {
            this.$.readmode.notifyResize();
            this.$.chunkmode.notifyResize();
            this.$.reviewmode.notifyResize();
            this.$.conflictmode.notifyResize();
        },

        resolveConflict: function () {
            this.set('currentproject.conflicts', this.currentproject.conflicts - 1);
            if (this.currentproject.conflicts === 0 && this.selected === 5) {
                this.set('selected', 3);
            }
        },

        updatestate: function (event, data) {
            var id = data.id;
            var mode = data.mode;
            this.currentproject.statedata[id][mode] = data.value;
        },

        savestate: function () {
            if (this.route === "translate") {
                var key = this.currentproject.projectmeta.unique_id;
                this.getlocation();
                App.configurator.setValue(key + "-chapter", this.modestatus.chapter);
                App.configurator.setValue(key + "-index", this.modestatus.index);
                App.configurator.setValue(key + "-selected", this.selected);
            }
        },

        updatecompletion: function () {
            var chunks = this.currentproject.chunks;
            var finished = [];

            for (var i = 0; i < chunks.length; i++) {
                if (chunks[i].completed) {
                    finished.push(chunks[i].chunkmeta.chapterid + "-" + chunks[i].chunkmeta.frameid);
                }
            }

            this.set('currentproject.projectmeta.finished_chunks', finished);
            this.savemanifest();
        },

        savesource: function () {
            var key = this.currentproject.projectmeta.unique_id;
            var source = this.currentproject.projectmeta.currentsource;
            if (source !== null) {
                App.configurator.setValue(key + "-source", source);
            } else {
                App.configurator.unsetValue(key + "-source");
            }
        },

        retrievesource: function () {
            var key = this.currentproject.projectmeta.unique_id;
            var source = App.configurator.getValue(key + "-source");
            if (source && source < this.currentproject.projectmeta.source_translations.length) {
                this.set('currentproject.projectmeta.currentsource', source);
            }
        },

        loadproject: function (event, data) {
            var mythis = this;
            var nav = data.nav;
            var projectmeta = data.projectmeta;
            var list = this.projectlist;

            var loadsource = function () {
                if (projectmeta.project_type_class === "extant") {
                    mythis.createextantchunks();
                } else {
                    mythis.createchunks();
                    mythis.createchapters();
                }
                if (nav === "review") {
                    mythis.goreview();
                } else {
                    mythis.fire('iron-signal', {name: 'closeloading'});
                }
                setTimeout(function() {
                    if (nav === "translate") {
                        mythis.setmodestate();
                        mythis.checksources();
                        mythis.starttimers();
                    } else if (nav === "print") {
                        mythis.fire('openprint');
                    } else if (nav === "export") {
                        mythis.fire('saveusfm');
                    }
                }, 500);
            };

            var loadwords = function () {
                if (projectmeta.project_type_class !== "extant") {
                    var wordmeta = false;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].target_language.id === projectmeta.target_language.id && list[i].type.id === "tw") {
                            wordmeta = list[i];
                        }
                    }
                    if (wordmeta) {
                        App.projectsManager.loadTargetTranslation(wordmeta).then(function (words) {
                            mythis.set('currentproject.rawdata.words', words);
                            loadsource();
                        });
                    } else {
                        mythis.set('currentproject.rawdata.words', {});
                        loadsource();
                    }
                } else {
                    mythis.set('currentproject.rawdata.words', {});
                    loadsource();
                }
            };

            var loaddata2 = function () {
                if (projectmeta.project_type_class === "helps") {
                    var secondmeta = false;
                    for (var i = 0; i < list.length; i++) {
                        if (list[i].project.id === projectmeta.project.id && list[i].target_language.id === projectmeta.target_language.id && (list[i].resource.id === "ulb" || list[i].resource.id === "obs")) {
                            secondmeta = list[i];
                        }
                    }
                    if (!secondmeta) {
                        for (i = 0; i < list.length; i++) {
                            if (list[i].project.id === projectmeta.project.id && list[i].target_language.id === projectmeta.target_language.id && (list[i].resource.id === "udb" || list[i].resource.id === "reg")) {
                                secondmeta = list[i];
                            }
                        }
                    }
                    if (secondmeta) {
                        App.projectsManager.loadTargetTranslation(secondmeta).then(function (secondtranslation) {
                            mythis.set('currentproject.rawdata.second', secondtranslation);
                            loadwords();
                        });
                    } else {
                        mythis.set('currentproject.rawdata.second', {});
                        loadwords();
                    }
                } else {
                    mythis.set('currentproject.rawdata.second', {});
                    loadwords();
                }
            };

            this.setrightanimation();
            mythis.set('currentproject.projectmeta', projectmeta);
            mythis.set('currentproject.statedata', {});
            mythis.set('currentproject.rawdata', {});
            mythis.set('currentproject.conflicts', 0);
            mythis.retrievesource();
            if (nav === "translate") {
                mythis.route = "translate";
            }
            setTimeout(function() {
                mythis.set('options', {});
                mythis.set('options.body', "Loading project. Please wait...");
                mythis.set('options.loading', true);
                mythis.fire('iron-signal', {name: 'openloading'});
                setTimeout(function() {
                    return App.projectsManager.loadTargetTranslation(projectmeta)
                        .then(function (translation) {
                            mythis.set('currentproject.rawdata.main', translation);
                            if (projectmeta.type.id === "ta") {
                                throw "At this time, translationAcademy translation projects are not supported.";
                            }
                            loaddata2();
                        })
                        .catch(function(err) {
                            App.reporter.logError(err);
                            var errmessage = "An error occurred while trying to load this project";
                            if(err !== null) {
                                errmessage = err;
                            }
                            mythis.set('route', 'home');
                            mythis.set('options.title', "Project Load Failed");
                            mythis.set('options.body', errmessage);
                            mythis.set('options.loading', false);
                        });
                }, 250);
            }, 500);
        },

        updatesources: function (event, data) {
            var mythis = this;
            mythis.set('options', {});
            mythis.set('options.body', "Loading source. Please wait...");
            mythis.set('options.loading', true);
            mythis.fire('iron-signal', {name: 'openloading'});
            setTimeout(function() {
                mythis.set('currentproject.projectmeta.source_translations', data.sources);
                mythis.set('currentproject.projectmeta.currentsource', data.current);
                mythis.savemanifest();
                mythis.savesource();
                mythis.getlocation();
                mythis.reloaddata(data.full);
            }, 250);
        },

        reloaddata: function (full) {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;
            var source = projectmeta.source_translations[projectmeta.currentsource];

            var open = function () {
                return App.dataManager.activateProjectContainers(source.language_id, projectmeta.project.id, source.resource_id)
            };

            var checkOpen = source ? open() : Promise.resolve(true);

            checkOpen
                .then(function () {
                    return App.projectsManager.loadTargetTranslation(projectmeta);
                })
                .then(function (translation) {
                    mythis.set('currentproject.rawdata.main', translation);
                    mythis.createchunks();
                    mythis.createchapters();
                    mythis.fire('iron-signal', {name: 'closeloading'});
                    mythis.forceResize();
                    mythis.setlocation();
                    if (full) {
                        mythis.checksources();
                    }
                });
        },

        savechunk: function (event, data) {
            if (this.saveoptions.chunks.indexOf(data.chunk.index) < 0) {
                this.push('saveoptions.chunks', data.chunk.index);
            }
            this.createchapters();
        },

        savemanifest: function () {
            this.set('saveoptions.manifest', true);
        },

        addcontributor: function () {
            var user = this.currentuser.full_name;
            var array = this.currentproject.projectmeta.translators;
            if (array.indexOf(user) === -1) {
                this.push('currentproject.projectmeta.translators', user);
                this.savemanifest();
            }
        },

        createchunks: function () {
            var projectmeta = this.currentproject.projectmeta;
            var selected = projectmeta.currentsource;
            if (selected === null || selected === undefined) {
                return;
            }
            var source = projectmeta.source_translations[selected];
            var container = source.language_id + "_" + source.project_id + "_" + source.resource_id;
            var frames = App.dataManager.getContainerData(container);
            var notes = App.dataManager.getSourceHelps(source, "tn");
            var questions = App.dataManager.getSourceHelps(source, "tq");
            var udb = App.dataManager.getSourceUdb(source);
            var wordlist = App.dataManager.getSourceWords(source);
            var chunkarray = [];
            var title = "";

            this.set('currentproject.conflicts', 0);

            for (var i = 0; i < frames.length; i++) {
                if (frames[i].chunk === "title") {
                    title = frames[i].content;
                }
                var resources = this.getFrameResources(frames[i], notes, questions, udb, wordlist);
                var sourcedata = App.renderer.convertVerseMarkers(frames[i].content);
                var chunkmeta = this.createFrameMeta(frames[i], projectmeta, sourcedata.verses, title);
                var chunk = this.getFrameData(chunkmeta, projectmeta);
                var sourcecontent = App.renderer.convertNoteMarkers(sourcedata.text);
                chunk.srccontent = App.renderer.renderSourceWithVerses(sourcecontent);
                chunk.wordcontent = "";
                chunk.resources = resources;
                chunk.index = i;
                chunk.search = {text: ""};
                chunkarray.push(chunk);
            }
            this.set('currentproject.chunks', chunkarray);
        },

        createchapters: function () {
            var projectmeta = this.currentproject.projectmeta;
            var current = projectmeta.currentsource;
            if (current === null || current === undefined || projectmeta.project_type_class !== "standard") {
                return;
            }
            var chunks = this.currentproject.chunks;
            var mythis = this;
            var chapters = [];

            _.forEach(_.groupBy(chunks, function(chunk) {
                return chunk.chunkmeta.chapter;
            }), function (data, chap) {
                var chapcomplete = true;
                var conflicts = false;
                var transcontent = "";
                var srccontent = "";
                var chaptermeta = {};

                _.forEach(data, function (chunk) {
                    if (chunk.chunkmeta.frame > 0) {
                        if (!chunk.completed) {
                            chapcomplete = false;
                        }
                        if (chunk.conflicts.exists) {
                            conflicts = true;
                        }
                        transcontent += chunk.transcontent + " ";
                        srccontent += chunk.srccontent + " ";
                        chaptermeta = chunk.chunkmeta;
                    }
                });
                var statedata = mythis.currentproject.statedata[chaptermeta.chapterid];
                if (!statedata) {
                    statedata = {read: true};
                    mythis.currentproject.statedata[chaptermeta.chapterid] = statedata;
                }
                if (chaptermeta.chapter > 0) {
                    chapters.push({completed: chapcomplete, conflicts: conflicts, transcontent: transcontent, srccontent: srccontent, projectmeta: _.cloneDeep(projectmeta), chaptermeta: chaptermeta, state: statedata});
                }
            });
            this.set('currentproject.chapters', chapters);
        },

        createextantchunks: function () {
            var projectmeta = this.currentproject.projectmeta;
            var type = projectmeta.type.id;
            var language = projectmeta.target_language.name;
            var frames;
            var volume = "vol1";
            var chunkarray = [];

            if (type === "tw") {
                var dict = projectmeta.project.id;
                frames = App.dataManager.getAllWords(dict);
            } else if (type === "ta") {
                if (projectmeta.project.id !== "ta") {
                    volume = projectmeta.project.id;
                }
                //frames = App.dataManager.getTa(volume);
            }

            for (var i = 0; i < frames.length; i++) {
                var chunkmeta = {
                    chapterid: "01",
                    chapter: 1,
                    frameid: frames[i].slug,
                    verses: [],
                    chunkref: frames[i].title,
                    refaddon: " — " + language
                };
                var chunk = this.getFrameData(chunkmeta, projectmeta);
                chunk.srccontent = frames[i].body;
                chunk.wordcontent = frames[i].title;
                chunk.resources = [];
                chunk.index = i;
                chunkarray.push(chunk);
            }
            this.set('currentproject.chunks', chunkarray);
        },

        getFrameResources: function (frame, notes, questions, udb, wordlist) {
            var resources = [];
            var note = [];
            var question = [];
            var words = [];
            var framewords = [];
            var udbtext = null;

            if (frame.chapter === "front") {
                return resources;
            }

            var framenotes = notes.filter(function (note) {
                return note.chapter === frame.chapter && note.chunk === frame.chunk;
            });
            if (framenotes.length) {
                note = framenotes[0].content;
            }
            if (note.length) {
                resources.push({title: "Notes", array: true, data: note});
            }

            if (wordlist && wordlist[frame.chapter] && wordlist[frame.chapter][frame.chunk]) {
                framewords = wordlist[frame.chapter][frame.chunk].words;
            }

            framewords.forEach(function (frameword) {
                var split = _.compact(frameword.split("/"));
                var word = App.dataManager.getWord(split[0], split[2]);

                if (word) {
                    words.push(word);
                } else {
                    console.log("Cannot find data for: " + frameword);
                }
            });

            for (var w = 0; w < words.length; w++) {
                var worddata = this.currentproject.rawdata.words["01-" + words[w].slug];
                if (worddata && worddata.helpscontent[0].body !== "" && worddata.helpscontent[0].title !== "") {
                    words[w].title = worddata.helpscontent[0].title;
                    words[w].body = worddata.helpscontent[0].body;
                }
            }

            if (words.length) {
                resources.push({title: "Words", array: true, data: words});
            }

            var frameques = questions.filter(function (ques) {
                return ques.chapter === frame.chapter && ques.chunk === frame.chunk;
            });
            if (frameques.length) {
                question = frameques[0].content;
            }
            if (question.length) {
                resources.push({title: "Questions", array: true, data: question});
            }

            var frameudb = udb.filter(function (chunk) {
                return chunk.chapter === frame.chapter && chunk.chunk === frame.chunk;
            });
            if (frameudb.length) {
                udbtext = frameudb[0].content;
            }
            if (udbtext) {
                udbtext = App.renderer.convertVerseMarkers(udbtext).text;
                udbtext = App.renderer.renderSourceWithVerses(udbtext);
                resources.push({title: "UDB", array: false, data: [udbtext]});
            }

            return resources;
        },

        createFrameMeta: function (frame, projectmeta, verses, title) {
            var refaddon = projectmeta.target_language.name;
            var resource = projectmeta.resource.id;
            var name = projectmeta.project.name;
            var chapterid = frame.chapter;
            var chapternum = parseInt(chapterid);
            var frameid = frame.chunk;
            var framenum = parseInt(frameid);
            var chapterref;
            var chunkref;

            if (resource === "ulb" || resource === "udb") {
                refaddon += " (" + resource + ")";
            }

            if (name === "Open Bible Stories") {
                if (chapterid === "front" && frameid === "title") {
                    chapterref = "Project Title";
                    chunkref = "Project Title";
                    framenum = 0;
                } else if (frameid === "title") {
                    chapterref = "Story Title";
                    chunkref = "Story Title";
                    framenum = 0;
                } else if (frameid === "reference") {
                    chapterref = "Story Reference";
                    chunkref = "Story Reference";
                    framenum = 0;
                } else {
                    chapterref = title;
                    chunkref = title + ":" + framenum;
                }
            } else {
                if (chapterid === "front" && frameid === "title") {
                    chapterref = "Project Title";
                    chunkref = "Project Title";
                    framenum = 0;
                } else {
                    chapterref = name + " " + chapternum;
                    chunkref = name + " " + chapternum + ":" + verses[0] + "–" + verses[verses.length-1];
                }
            }

            return {
                chapter: chapternum,
                frame: framenum,
                chapterid: chapterid,
                frameid: frameid,
                verses: verses,
                chapterref: chapterref,
                chunkref: chunkref,
                refaddon: " — " + refaddon
            };
        },

        getFrameData: function (chunkmeta, projectmeta) {
            var typeclass = projectmeta.project_type_class;
            var complexid = chunkmeta.chapterid + '-' + chunkmeta.frameid;
            var verses = chunkmeta.verses;
            var maindata = this.currentproject.rawdata.main[complexid];
            var seconddata = this.currentproject.rawdata.second[complexid];
            var statedata = this.currentproject.statedata[complexid];
            var completed = projectmeta.finished_chunks.indexOf(complexid) >= 0;
            var transcontent = "";
            var helpscontent = [];
            var conflicts = {exists: false};

            if (typeclass === "extant") {
                helpscontent = [{title: "", body: ""}];
            }

            if (maindata) {
                if (typeclass === "standard") {
                    transcontent = maindata.transcontent;
                    conflicts = this.checkForConflicts(transcontent);
                    if (conflicts.exists) {
                        for (var i = 0; i < conflicts.array.length; i++) {
                            conflicts.array[i] = App.renderer.convertVerseMarkers(conflicts.array[i]).text;
                            conflicts.array[i] = App.renderer.migrateMarkers(conflicts.array[i]);
                            conflicts.array[i] = App.renderer.removeChapterMarkers(conflicts.array[i]);
                            conflicts.array[i] = App.renderer.validateVerseMarkers(conflicts.array[i], verses);
                        }
                    } else {
                        transcontent = App.renderer.convertVerseMarkers(transcontent).text;
                        transcontent = App.renderer.migrateMarkers(transcontent);
                        transcontent = App.renderer.removeChapterMarkers(transcontent);
                        transcontent = App.renderer.validateVerseMarkers(transcontent, verses);
                    }
                } else {
                    helpscontent = maindata.helpscontent;
                    conflicts = this.checkForConflicts(helpscontent);
                }
            }
            if (seconddata && typeclass === "helps") {
                transcontent = seconddata.transcontent;
                transcontent = App.renderer.migrateMarkers(transcontent);
                transcontent = App.renderer.removeChapterMarkers(transcontent);
            }
            if (!statedata) {
                statedata = {chunk: true, review: true, resource: 0};
                this.currentproject.statedata[complexid] = statedata;
            }
            return {projectmeta: _.cloneDeep(projectmeta), chunkmeta: chunkmeta, transcontent: transcontent, helpscontent: helpscontent, conflicts: conflicts, completed: completed, state: statedata};
        },

        checkForConflicts: function (content) {
            var conflicttest = new RegExp(/(<{7} HEAD\n|={7}\n)([^<=>]+)(\n>{7} [\w]{40}|\n={7})/);
            var conarray = [];

            if (conflicttest.test(content)) {
                while (conflicttest.test(content)) {
                    var subcontent = conflicttest.exec(content)[2];
                    conarray.push(subcontent);
                    content = content.replace(subcontent, "");
                }
            } else {
                return {exists: false, array: conarray};
            }
            this.set('currentproject.conflicts', this.currentproject.conflicts + 1);
            return {exists: true, array: conarray};
        },

        modechange: function (tomode, frommode) {
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;
            var nosource = this.$.nosourcemode;
            var conflict = this.$.conflictmode;

            if (frommode > 0) {
                this.set('modestatus.lastmode', frommode);
            }

            if (frommode === 1) {
                read.frommode();
            } else if (frommode === 2) {
                chunk.frommode();
            } else if (frommode === 3) {
                review.frommode();
            } else if (frommode === 4) {
                nosource.frommode();
            } else if (frommode === 5) {
                conflict.frommode();
            }

            if (tomode === 1) {
                read.tomode();
            } else if (tomode === 2) {
                chunk.tomode();
            } else if (tomode === 3) {
                review.tomode();
            } else if (tomode === 4) {
                nosource.tomode();
            } else if (tomode === 5) {
                conflict.tomode();
            }
        },

        reset: function () {
            var mythis = this;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;
            var nosource = this.$.nosourcemode;
            var conflict = this.$.conflictmode;

            mythis.set('selected', 0);
            mythis.set('modestatus', {"chapter": 1, "lastmode": 1, "index": -1});
            read.classList.add("hide");
            chunk.classList.add("hide");
            review.classList.add("hide");
            nosource.classList.add("hide");
            conflict.classList.add("hide");
            mythis.stoptimers();
        },

        setmodestate: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var sources = projectmeta.source_translations;
            var key = projectmeta.unique_id;
            var index = App.configurator.getValue(key + "-index");
            var chapter = App.configurator.getValue(key + "-chapter");
            var selected = App.configurator.getValue(key + "-selected");
            var typeclass = projectmeta.project_type_class;

            if (chapter > 0) {
                mythis.set('modestatus.chapter', chapter);
            }
            if (index >= 0) {
                mythis.set('modestatus.index', index);
            }
            if (typeclass === "standard") {
                mythis.set('modestatus.lastmode', 1);
            } else {
                mythis.set('modestatus.lastmode', 3);
            }

            if ((sources !== undefined && sources.length !== 0) || typeclass === "extant") {
                setTimeout(function() {
                    if (selected > 0) {
                        mythis.set('selected', selected);
                    } else {
                        if (typeclass === "standard") {
                            mythis.set('selected', 1);
                        } else {
                            mythis.set('selected', 3);
                        }
                    }
                }, 500);
            }
        },

        checksources: function () {
            var mythis = this;
            var projectmeta = this.currentproject.projectmeta;
            var sources = projectmeta.source_translations;
            var lastmode = this.modestatus.lastmode;
            var selected = this.selected;
            var typeclass = projectmeta.project_type_class;

            if (selected === 4) {
                if (sources !== undefined && sources.length !== 0) {
                    mythis.set('selected', lastmode);
                }
            } else {
                if ((sources === undefined || sources.length === 0) && typeclass !== "extant") {
                    setTimeout(function() {
                        mythis.set('selected', 4);
                    }, 500);
                }
            }
        },

        getlocation: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;

            if (selected === 1) {
                read.getlocation();
            } else if (selected === 2) {
                chunk.getlocation();
            } else if (selected === 3) {
                review.getlocation();
            }
        },

        setlocation: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;
            var review = this.$.reviewmode;
            var conflict = this.$.conflictmode;

            if (selected === 1) {
                read.setlocation();
            } else if (selected === 2) {
                chunk.setlocation();
            } else if (selected === 3) {
                review.setlocation();
            } else if (selected === 5) {
                conflict.setlocation();
            }
        },

        setheights: function () {
            var selected = this.selected;
            var read = this.$.readmode;
            var chunk = this.$.chunkmode;

            if (selected === 1) {
                read.setheights();
            } else if (selected === 2) {
                chunk.setheights();
            }
        },

        fromreview: function (event, data) {
            var mythis = this;

            if (data.index === null) {
                mythis.set('route', "translate");
                mythis.setmodestate();
                mythis.checksources();
                mythis.starttimers();
            } else {
                mythis.set('selected', 0);
                mythis.set('modestatus.index', data.index);
                mythis.set('route', "translate");
                setTimeout(function() {
                    mythis.set('selected', 3);
                    mythis.starttimers();
                }, 500);
            }
        },

        gohome: function () {
            var mythis = this;
            mythis.$.reviewmode.closeresource();
            mythis.$.conflictmode.closeresource();
            mythis.savestate();
            mythis.stoptimers();
            return mythis.saveAll()
                .then(function () {
                    setTimeout(function() {
                        mythis.fire('iron-signal', {name: 'closeloading'});
                        mythis.set('route', "home");
                        mythis.reset();
                    }, 500);
                });
        },

        goreview: function () {
            var mythis = this;
            var typeclass = mythis.currentproject.projectmeta.project_type_class;
            if (mythis.currentproject.projectmeta.source_translations.length || typeclass === "extant") {
                mythis.set('options', {});
                mythis.set('options.body', "Loading review page. Please wait...");
                mythis.set('options.loading', true);
                mythis.fire('iron-signal', {name: 'openloading'});
                setTimeout(function() {
                    mythis.$.reviewmode.closeresource();
                    mythis.$.conflictmode.closeresource();
                    mythis.savestate();
                    mythis.setleftanimation();
                    mythis.stoptimers();
                    return mythis.saveAll()
                        .then(function () {
                            mythis.fire('iron-signal', {name: 'updatereview'});
                            mythis.fire('iron-signal', {name: 'closeloading'});
                            mythis.set('route', "review");
                        });
                }, 250);
            } else {
                mythis.set('options', {});
                mythis.set('options.title', "Project Empty");
                mythis.set('options.body', "This project has nothing to review");
                mythis.set('options.loading', false);
                mythis.fire('iron-signal', {name: 'openloading'});
            }
        },

        goprint: function () {
            this.fire('openprint');
        },

        goexport: function () {
            var mythis = this;
            var projectmeta = mythis.currentproject.projectmeta;
            mythis.stoptimers();
            return mythis.saveAll()
                .then(function () {
                    mythis.fire('iron-signal', {name: 'closeloading'});
                    mythis.fire('iron-signal', {name: 'openexport', data: {projectmeta: projectmeta}});
                    mythis.starttimers();
                });
        },

        gosettings: function () {
            this.savestate();
            this.setleftanimation();
            App.configurator.setValue("backto", this.route);
            this.route = "settings";
        },

        gosearch: function () {
            var review = this.$.reviewmode;
            review.opensearch();
        },

        setrightanimation: function () {
            this.animationConfig.exit.name = 'slide-right-animation';
            this.animationConfig.entry.name = 'slide-from-right-animation';
        },

        setleftanimation: function () {
            this.animationConfig.exit.name = 'slide-left-animation';
            this.animationConfig.entry.name = 'slide-from-left-animation';
        },

        ready: function() {
            var mythis = this;
            this.reset();
            window.addEventListener("resize", function () {
                mythis.getlocation();
                mythis.setlocation();
                mythis.setheights();
            });
        }

    });

</script>
